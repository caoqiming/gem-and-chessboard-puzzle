# 解法

将黑色棋子当作 1，白色棋子当作 0， 显然这个问题可以看作一个编码问题。本质是要找到一个 64 位到 6 位的一个编码方案，要求任意原码的汉明距离为 1 的原码（共 64 个）编码之后恰好对应目的码所有可能的取值 2^6=64
汉明纠错码就是一个完美的答案。
我们将 64 个位的地址用二进制表示，从 0 开始

```
000000,000001,...,111111
```

将其中只有 1 个 1 的地址拿出来作为基偶校验位，其余的看作数据位，也就是说一共有 6 个校验位，分别为

```
000001,000010,000100,001000,010000,100000
```

其对应的十进制为 1，2，4，8，16，32
如果一个数据位的地址的某 1 位为 1，那么该数据位就会参与对应的校验位的计算。比如说地址为 50 (二进制为 110010) 的数据位需要参与地址为 32，16，2 这三个校验位的计算（$50 = 32 + 16 + 2$）
这样以来，就可以得到一个预期的 6 位校验结果，将预期的校验结果与实际校验位上的数字比较，进行异或运算，就可以得到一个伴随式（syndrome），这个伴随式可能指向任意一个地址。
这时最精彩的部分来了。因为玩家 A 是可以选择翻转任意一个位置的棋子的。玩家 A 现在要做的就是翻转一个棋子使得翻转后的伴随式指向宝石所在的位置。那么玩家 A 应该翻转哪一个位置的棋子呢？

因为翻转任意位置的棋子，会让其参与运算的校验码发生翻转，也就是说新的伴随式就是旧的伴随式与翻转棋子的地址相异或的结果。

$$
current\_syndrome \bigoplus flip\_location = new\_syndrome
$$

我们希望翻转后的伴随式指向宝石所在的位置，也就是说我们希望

$$
current\_syndrome \bigoplus flip\_location = gem\_location
$$

因为异或运算的特性，我们很容易得出

$$
current\_syndrome \bigoplus current\_syndrome \bigoplus flip\_location = current\_syndrome \bigoplus gem\_location
$$

$$
flip\_location = current\_syndrome \bigoplus gem\_location
$$

此时答案已经呼之欲出了
只需要将宝石所在的地址与当前伴随式进行异或运算即可！

细心的人可能发现地址为 0 的棋子没有参与任何运算。事实上这颗棋子确实没用到，只是在恰好当前的伴随式就是宝石的地址时我们会选择翻转这颗棋子，相当于没有发生任何变化。如果允许玩家 A 选择不翻转任何棋子的话，那么棋盘上缺少一个位置（总数为 2^-1）也是可以的。

当然要玩这个游戏棋盘不一定必须是 8\*8，事实上只要棋子的总数是 2 的整数次幂就可以。

> 该解法参考了内存的纠错算法，其实也就是汉明码
